# RulesEngine.Linq Audit — 2026-02-05

Comprehensive audit after implementing ContextConditionProjector and generic rewriter dispatch.
All 311 tests passing at time of audit.

---

## Bugs (Correctness)

### 1. ~~`TotalRulesEvaluated` is always 0~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `Evaluate()` method
**Issue:** `totalRules` was initialized to 0 and never incremented.
**Fix:** Added `RulesEvaluated` property to `EvaluationResultImpl<T>`, set from `rules.Count` in `EvaluateFactSet<T>`, read back via reflection in `Evaluate()` — same pattern as existing `Matches` and `Count` reads.
**Test:** `SessionTests.Session_Evaluate_ReportsTotalRulesEvaluated` — verifies 2 rules yield `TotalRulesEvaluated == 2`.

### 2. Stale cache on re-evaluation
**File:** `Implementation.cs` — `_rewrittenConditionCache` (Path 3), `Rule.cs` — `_sessionCompiledCache` (Path 2)
**Issue:** Both caches bake session fact data into compiled delegates via `Expression.Constant(facts)`. If a session inserts more facts after the first `Evaluate()` call and evaluates again, cached delegates still reference the old fact snapshot. Results are silently wrong.
**Fix:** Either (a) invalidate caches when facts change, (b) clear caches at the start of each `Evaluate()`, or (c) document that sessions are single-evaluate-only and enforce it.

### 3. `Rule<T>.ClearSessionCache` is never called
**File:** `Rule.cs` — `ClearSessionCache(string sessionId)`, `Implementation.cs` — `RuleSession.Dispose()`
**Issue:** `RuleSession.Dispose()` doesn't call `ClearSessionCache` on any rules. Each session leaves behind compiled delegates (holding references to fact data via closures) inside every cross-fact rule it touched. This is a memory leak proportional to session count × cross-fact rule count.
**Fix:** `RuleSession.Dispose()` should iterate its rules and call `ClearSessionCache`.

### 4. Detector/Rewriter asymmetry
**File:** `Provider.cs` — `FactQueryDetector` vs `FactQueryRewriter`
**Issue:** `FactQueryDetector.VisitConstant` detects `FactQueryable<T>` in constant nodes. `FactQueryRewriter` does NOT override `VisitConstant`, so it can't rewrite those same nodes. Both classes DO handle `VisitMember` (closure member access) and `VisitExtension` (direct `FactQueryExpression`).
**Risk (revised 2026-02-06):** Lower than originally assessed. C# closure capture always wraps variables in `MemberAccess(Constant(DisplayClass), fieldName)` — never as a bare `ConstantExpression`. Both detector and rewriter handle `VisitMember`. The gap only affects hand-built expression trees using `Expression.Constant(factQueryable)` directly. Failure mode is NOT silent — `FactQueryable.GetEnumerator()` throws `InvalidOperationException`, caught by the error handler in `EvaluateFactSet` (line 599). Rule is skipped and appears in `Errors`. **Downgraded from P0 to P2.**
**Fix:** `FactQueryRewriter` should add `VisitConstant` to match `FactQueryDetector` for completeness.

### 5. `ContainsFactQuery()` called per-fact, not per-rule
**File:** `Implementation.cs` — `EvaluateFactSet<T>()`, Path 3 dispatch
**Issue:** The check `FactQueryExpression.ContainsFactQuery(rule.Condition)` is inside the fact loop, walking the entire expression tree once per fact per rule. For 100 facts × 10 rules, that's 1000 expression tree walks instead of 10.
**Fix:** Hoist the detection outside the fact loop. Check once per rule, cache the result.

### 6. `Evaluate<T>()` single-type overload skips state transition
**File:** `Implementation.cs` — `Evaluate<T>()` vs `Evaluate()`
**Issue:** The full `Evaluate()` method sets `_state = SessionState.Evaluating` which blocks `Insert()` during evaluation. The single-type `Evaluate<T>()` overload skips this, meaning rule actions could call `session.Insert()` during evaluation, mutating facts mid-evaluation.
**Fix:** Single-type `Evaluate<T>()` should also set state to `Evaluating` and restore it afterward.

---

## Design Flaws (Consistency)

### 7. `DependentRule.Execute` vs `Rule<T>.Execute` inconsistency
**File:** `DependencyAnalysis.cs` — `DependentRule<T>.Execute()`, `Rule.cs` — `Rule<T>.Execute()`
**Issue:** `Rule<T>.Execute()` checks the condition first and returns `RuleResult.NoMatch` if false. `DependentRule<T>.Execute()` runs the action unconditionally and returns `RuleResult.Success`. A caller using `Execute()` without prior `Evaluate()` gets different behavior depending on the rule type.
**Impact:** Low — `EvaluateFactSet` always checks the condition first. But the asymmetry is a trap for direct callers.

### 8. `FindByKey` ignores schema's `HasKey` configuration
**File:** `Implementation.cs` — `FactSet<T>.FindByKey()`, `DependencyAnalysis.cs` — `FactTypeSchemaBuilder.HasKey()`
**Issue:** `FindByKey` always looks for a property named `"Id"` via reflection and uses string comparison. The `FactTypeSchemaBuilder.HasKey()` configuration exists but is completely ignored by `FindByKey`.
**Impact:** Medium — misleading API. Users configure `HasKey(x => x.Code)` but `FindByKey("ABC")` still searches for property `Id`.

### 9. `RegisteredFactTypes` returns wrong set
**File:** `Implementation.cs` — `RuleSession.RegisteredFactTypes`
**Issue:** `IFactContext.RegisteredFactTypes` is semantically "all registered fact types in the schema" but the implementation returns only types that have been inserted into the session via `InsertAll<T>()`.
**Impact:** Medium — `DependentRule` actions that check `RegisteredFactTypes` to decide whether to query a fact type will get inconsistent answers depending on insertion order.

### 10. `GetFacts()` returns the live backing list
**File:** `Implementation.cs` — `FactSet<T>.GetFacts()`
**Issue:** Returns the internal `List<T>` directly (cast as `IReadOnlyList<T>`). Callers can downcast to `List<T>` and mutate it. The rewriter's `Expression.Constant(facts)` captures this same reference, so external mutations propagate into compiled rule conditions unpredictably.
**Fix:** Return `_facts.AsReadOnly()` or a snapshot copy.

---

## Test Coverage Gaps

### 11. Zero tests for DependencyGraph cycle detection
**File:** `DependencyAnalysis.cs` — `TopologicalVisit()`, `WouldCreateCycle()`
**Missing:** No tests for direct cycles (A→B→A), transitive cycles (A→B→C→A), self-referential (A→A), or that `GetLoadOrder()` throws `InvalidOperationException` on cycles.

### 12. Zero tests for error accumulation in EvaluateFactSet
**File:** `Implementation.cs` — `EvaluateFactSet` try-catch, `_errors` list
**Missing:** No test ever verifies that `IEvaluationResult.HasErrors` returns true or that exceptions from rule evaluation are captured in the errors list. Exceptions are silently swallowed.

### 13. Zero tests for ContextConditionProjector error paths
**File:** `DependencyAnalysis.cs` — `ContextConditionProjector.VisitMethodCall()`
**Missing:** `FindByKey<T>()` should throw `NotSupportedException`. Unsupported `IFactContext` methods should throw. Neither is tested.

### 14. False-positive test: `ClosureCapture_SessionCacheIsUsed_ForSameSession`
**File:** `FactContextIntegrationTests.cs`
**Issue:** Test name claims to verify cache usage but only verifies two messages match the same rule. Passes identically with or without caching. No observable behavior proves the cache was consulted.

### 15. Zero tests for multiple `Evaluate()` calls on same session
**Missing:** The stale-cache bug (#2) has no test proving or disproving intended behavior. Is a session meant for single evaluation? Document and test either way.

### 16. Zero tests for session lifecycle edge cases
**Missing:** Using a disposed session, inserting after rollback, double-dispose.

---

## Dead Code

### 17. `FactWithRulesQueryable<T>` (Rule.cs)
Never instantiated anywhere. Would break on rewriting-required rules (no `GetOrCompileWithRewriter` implementation).

### 18. `DependencyExtractor._currentFactType` (DependencyAnalysis.cs)
Field is assigned but never read.

---

## Priority Order for Fixes

| Priority | Item | Risk |
|----------|------|------|
| **P0** | #2 Stale cache on re-evaluation | Silent wrong results |
| **P1** | #5 ContainsFactQuery per-fact perf | O(facts × rules × tree-depth) waste |
| **P1** | #3 Memory leak — ClearSessionCache never called | Unbounded memory growth |
| ~~**P1**~~ | ~~#1 TotalRulesEvaluated always 0~~ | ~~Broken metrics~~ **FIXED 2026-02-06** |
| **P1** | #6 Evaluate<T> skips state transition | Mutation during evaluation |
| **P1** | #11 Cycle detection untested | Could corrupt graph silently |
| **P2** | #4 Detector/Rewriter asymmetry (downgraded) | Hand-built expr trees only; throws, not silent |
| **P2** | #12 Error accumulation untested | Silent exception swallowing |
| **P2** | #13 Projector error paths untested | Undocumented failure modes |
| **P2** | #10 GetFacts returns live list | Unpredictable mutations |
| **P2** | #8 FindByKey ignores HasKey | Misleading API |
| **P2** | #9 RegisteredFactTypes wrong set | Inconsistent query behavior |
| **P3** | #7 Execute inconsistency | Trap for direct callers |
| **P3** | #14-16 Test quality issues | False confidence |
| **P3** | #17-18 Dead code | Cleanup |
