# RulesEngine.Linq Audit — 2026-02-05

Comprehensive audit after implementing ContextConditionProjector and generic rewriter dispatch.
All 311 tests passing at time of audit.

---

## Bugs (Correctness)

### 1. ~~`TotalRulesEvaluated` is always 0~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `Evaluate()` method
**Issue:** `totalRules` was initialized to 0 and never incremented.
**Fix:** Added `RulesEvaluated` property to `EvaluationResultImpl<T>`, set from `rules.Count` in `EvaluateFactSet<T>`, read back via reflection in `Evaluate()` — same pattern as existing `Matches` and `Count` reads.
**Test:** `SessionTests.Session_Evaluate_ReportsTotalRulesEvaluated` — verifies 2 rules yield `TotalRulesEvaluated == 2`.

### 2. ~~Stale cache on re-evaluation~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `_rewrittenConditionCache` (Path 3), `Rule.cs` — `_sessionCompiledCache` (Path 2)
**Issue:** Both caches baked session fact data into compiled delegates via `Expression.Constant(facts)`. If a session inserted more facts after the first `Evaluate()` call and evaluated again, cached delegates still referenced the old fact snapshot.
**Fix:** Clear both caches at the start of each `EvaluateFactSet<T>()`: `_rewrittenConditionCache.Clear()` for Path 3 and `Rule<T>.ClearSessionCache(SessionId)` for Path 2. Rewriter creates fresh delegates on each evaluation.
**Tests:** `Session_ReEvaluation_ReflectsNewlyInsertedFactType` (Path 2), `Session_ReEvaluation_Path3_ReflectsNewFacts` (Path 3).

### 3. ~~`Rule<T>.ClearSessionCache` is never called~~ **FIXED 2026-02-06**
**File:** `Rule.cs` — `ClearSessionCache(Guid sessionId)`, `Implementation.cs` — `RuleSession.Dispose()`
**Issue:** `RuleSession.Dispose()` didn't call `ClearSessionCache` on any rules. Each session left behind compiled delegates inside every cross-fact rule it touched.
**Fix:** `RuleSession.Dispose()` now calls `ClearAllRuleSessionCaches()`, which iterates all fact types and calls `ClearSessionCache(SessionId)` on each `Rule<T>`. Also clears `_rewrittenConditionCache`.

### 4. ~~Detector/Rewriter asymmetry~~ **FIXED 2026-02-06**
**File:** `Provider.cs` — `FactQueryDetector` vs `FactQueryRewriter`
**Issue:** `FactQueryDetector.VisitConstant` detects `FactQueryable<T>` in constant nodes. `FactQueryRewriter` did NOT override `VisitConstant`, so it couldn't rewrite those same nodes. Both classes DO handle `VisitMember` (closure member access) and `VisitExtension` (direct `FactQueryExpression`).
**Risk (revised 2026-02-06):** Lower than originally assessed. C# closure capture always wraps variables in `MemberAccess(Constant(DisplayClass), fieldName)` — never as a bare `ConstantExpression`. The gap only affects hand-built expression trees using `Expression.Constant(factQueryable)` directly. **Downgraded from P0 to P2.**
**Fix:** Added `VisitConstant` override to `FactQueryRewriter` that mirrors `FactQueryDetector.VisitConstant`, resolving bare `FactQueryable<T>` constants to actual session data.
**Test:** `Rewriter_HandlesBareFactQueryableConstant` — hand-built expression with bare `FactQueryable<Agent>` constant evaluates correctly after rewriting.

### 5. ~~`ContainsFactQuery()` called per-fact, not per-rule~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `EvaluateFactSet<T>()`, Path 3 dispatch
**Issue:** The check `FactQueryExpression.ContainsFactQuery(rule.Condition)` was inside the fact loop, walking the entire expression tree once per fact per rule.
**Fix:** Restructured `EvaluateFactSet<T>()` to pre-classify rules into a `List<(IRule<T>, RuleDispatchKind)>` before the fact loop. Classification (including `ContainsFactQuery`) runs once per rule. Inner loop uses `switch (kind)` dispatch. Added private `RuleDispatchKind` enum (Dependent, ClosureRewriting, GenericRewriting, Standard).

### 6. ~~`Evaluate<T>()` single-type overload skips state transition~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `Evaluate<T>()` vs `Evaluate()`
**Issue:** The single-type `Evaluate<T>()` overload skipped setting `_state = SessionState.Evaluating`, meaning rule actions could call `session.Insert()` during evaluation.
**Fix:** `Evaluate<T>()` now sets `_state = SessionState.Evaluating` in a try/finally block, matching `Evaluate()`.
**Test:** `SessionTests.Session_EvaluateT_SetsStateToEvaluating` — captures session state during a rule action and verifies it was `Evaluating`.

---

## Design Flaws (Consistency)

### 7. `DependentRule.Execute` vs `Rule<T>.Execute` inconsistency
**File:** `DependencyAnalysis.cs` — `DependentRule<T>.Execute()`, `Rule.cs` — `Rule<T>.Execute()`
**Issue:** `Rule<T>.Execute()` checks the condition first and returns `RuleResult.NoMatch` if false. `DependentRule<T>.Execute()` runs the action unconditionally and returns `RuleResult.Success`. A caller using `Execute()` without prior `Evaluate()` gets different behavior depending on the rule type.
**Impact:** Low — `EvaluateFactSet` always checks the condition first. But the asymmetry is a trap for direct callers.
**Note (2026-02-06):** Related: `Rule<T>.Evaluate()` and `Rule<T>.Execute()` have internal try-catch that swallows exceptions, while `DependentRule<T>.EvaluateWithContext()` and `ExecuteWithContext()` do NOT — their exceptions propagate to the session's error handler. This asymmetry means `_errors` only captures errors from DependentRule and custom IRule implementations, not from `Rule<T>`.

### 8. `FindByKey` ignores schema's `HasKey` configuration
**File:** `Implementation.cs` — `FactSet<T>.FindByKey()`, `DependencyAnalysis.cs` — `FactTypeSchemaBuilder.HasKey()`
**Issue:** `FindByKey` always looks for a property named `"Id"` via reflection and uses string comparison. The `FactTypeSchemaBuilder.HasKey()` configuration exists but is completely ignored by `FindByKey`.
**Impact:** Medium — misleading API. Users configure `HasKey(x => x.Code)` but `FindByKey("ABC")` still searches for property `Id`.
**Status (2026-02-06):** Validated, deferred. Fix requires schema lookup from session — larger API change.

### 9. `RegisteredFactTypes` returns wrong set
**File:** `Implementation.cs` — `RuleSession.RegisteredFactTypes`
**Issue:** `IFactContext.RegisteredFactTypes` is semantically "all registered fact types in the schema" but the implementation returns only types that have been inserted into the session via `InsertAll<T>()`.
**Impact:** Medium — `DependentRule` actions that check `RegisteredFactTypes` to decide whether to query a fact type will get inconsistent answers depending on insertion order.
**Status (2026-02-06):** Validated, deferred. Fix requires schema access from session — larger API change.

### 10. ~~`GetFacts()` returns the live backing list~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `FactSet<T>.GetFacts()`
**Issue:** Returns the internal `List<T>` directly (cast as `IReadOnlyList<T>`). Callers can downcast to `List<T>` and mutate it. The rewriter's `Expression.Constant(facts)` captures this same reference, so external mutations propagate into compiled rule conditions unpredictably.
**Fix:** Changed `GetFacts()` to return `_facts.AsReadOnly()`. `ReadOnlyCollection<T>` wraps the list and prevents downcast mutation.

---

## Test Coverage Gaps

### 11. ~~Zero tests for DependencyGraph cycle detection~~ **FIXED 2026-02-06**
**File:** `DependencyAnalysis.cs` — `TopologicalVisit()`, `WouldCreateCycle()`
**Fix:** Added 6 tests to `FactContextIntegrationTests`: direct cycle, transitive cycle, self-referential cycle (all throw `InvalidOperationException` on `GetLoadOrder()`); `WouldCreateCycle` detects direct and transitive cycles; valid dependency returns false.

### 12. ~~Zero tests for error accumulation in EvaluateFactSet~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `EvaluateFactSet` try-catch, `_errors` list
**Issue:** No test verified that `IEvaluationResult.HasErrors` returns true or that exceptions from rule evaluation are captured in the errors list.
**Fix:** Added 3 tests to `FactContextIntegrationTests`:
- `Session_Evaluate_CapturesRuleEvaluationErrors` — DependentRule with throwing context condition, verifies `HasErrors` and `Errors[0].RuleId`.
- `Session_Evaluate_ContinuesAfterRuleError` — throwing DependentRule + good Rule, verifies error captured AND good rule still matches.
- `Session_Evaluate_CapturesActionErrors` — DependentRule with throwing context action, verifies error captured.
**Note:** Tests use `DependentRule<T>` because `Rule<T>` has internal try-catch that swallows exceptions. Only `DependentRule<T>` and custom `IRule<T>` errors reach the session's error handler.

### 13. ~~Zero tests for ContextConditionProjector error paths~~ **FIXED 2026-02-06**
**File:** `DependencyAnalysis.cs` — `ContextConditionProjector.VisitMethodCall()`
**Fix:** Added test `DependentRule_FindByKeyInCondition_ThrowsNotSupported` — verifies accessing `.Condition` on a `DependentRule` with `ctx.FindByKey<T>()` in its condition throws `NotSupportedException`.
**Note:** The catch-all "unsupported IFactContext method" path is currently dead code — `IFactContext` only has `Facts<T>()` and `FindByKey<T>()`, and both are explicitly handled. No other methods exist to test.

### 14. False-positive test: `ClosureCapture_SessionCacheIsUsed_ForSameSession`
**File:** `FactContextIntegrationTests.cs`
**Issue:** Test name claims to verify cache usage but only verifies two messages match the same rule. Passes identically with or without caching. No observable behavior proves the cache was consulted.

### 15. ~~Zero tests for multiple `Evaluate()` calls on same session~~ **FIXED 2026-02-06**
**Fix:** The #2 fix tests (`Session_ReEvaluation_ReflectsNewlyInsertedFactType`, `Session_ReEvaluation_Path3_ReflectsNewFacts`) exercise multiple evaluations on the same session. Sessions support re-evaluation with correct cache invalidation.

### 16. ~~Zero tests for session lifecycle edge cases~~ **FIXED 2026-02-06**
**Fix:** Added 5 tests to `FactContextIntegrationTests`:
- `Session_InsertAfterDispose_Throws` — verifies `InvalidOperationException` on Insert after Dispose.
- `Session_InsertAfterRollback_Throws` — verifies `InvalidOperationException` on Insert after Rollback.
- `Session_EvaluateAfterDispose_Throws` — verifies `InvalidOperationException` on Evaluate after Dispose.
- `Session_DoubleDispose_IsNoOp` — verifies second Dispose is safe, state is Disposed.
- `Session_EvaluateAfterCommit_Throws` — verifies `InvalidOperationException` on Evaluate after Commit.

---

## Dead Code

### 17. ~~`FactWithRulesQueryable<T>` (Rule.cs)~~ **REMOVED 2026-02-06**
Never instantiated anywhere. Would break on rewriting-required rules (no `GetOrCompileWithRewriter` implementation). Removed.

### 18. ~~`DependencyExtractor._currentFactType` (DependencyAnalysis.cs)~~ **REMOVED 2026-02-06**
Field was assigned but never read. Removed.

---

## Priority Order for Fixes

| Priority | Item | Risk |
|----------|------|------|
| ~~**P0**~~ | ~~#2 Stale cache on re-evaluation~~ | ~~Silent wrong results~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#5 ContainsFactQuery per-fact perf~~ | ~~O(facts × rules × tree-depth) waste~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#3 ClearSessionCache never called~~ | ~~Unbounded memory growth~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#1 TotalRulesEvaluated always 0~~ | ~~Broken metrics~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#6 Evaluate<T> skips state transition~~ | ~~Mutation during evaluation~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#11 Cycle detection untested~~ | ~~Could corrupt graph silently~~ **FIXED 2026-02-06** |
| ~~**P2**~~ | ~~#4 Detector/Rewriter asymmetry~~ | ~~Hand-built expr trees only~~ **FIXED 2026-02-06** |
| ~~**P2**~~ | ~~#12 Error accumulation untested~~ | ~~Silent exception swallowing~~ **FIXED 2026-02-06** |
| ~~**P2**~~ | ~~#13 Projector error paths untested~~ | ~~Undocumented failure modes~~ **FIXED 2026-02-06** |
| ~~**P2**~~ | ~~#10 GetFacts returns live list~~ | ~~Unpredictable mutations~~ **FIXED 2026-02-06** |
| **P2** | #8 FindByKey ignores HasKey | Misleading API — **deferred** (larger API change) |
| **P2** | #9 RegisteredFactTypes wrong set | Inconsistent query behavior — **deferred** (larger API change) |
| **P3** | #7 Execute inconsistency | Trap for direct callers |
| ~~**P3**~~ | ~~#14 False-positive test~~ | ~~False confidence~~ (acknowledged, low impact) |
| ~~**P3**~~ | ~~#16 Session lifecycle untested~~ | **FIXED 2026-02-06** |
| ~~**P3**~~ | ~~#17-18 Dead code~~ | **REMOVED 2026-02-06** |

---

## Summary (2026-02-06)

**332 tests passing** (was 311 at audit time).

**Fixed:** #1, #2, #3, #4, #5, #6, #10, #11, #12, #13, #15, #16, #17, #18 (14 of 18 items)
**Remaining:** #7 (P3 design inconsistency), #8 (P2 API design), #9 (P2 API design), #14 (P3 test naming)

Items #8 and #9 are validated design flaws requiring larger API changes (schema access from session). Recommended for a future session with explicit API design planning.
