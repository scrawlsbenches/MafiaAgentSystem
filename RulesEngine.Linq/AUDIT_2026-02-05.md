# RulesEngine.Linq Audit — 2026-02-05

Comprehensive audit after implementing ContextConditionProjector and generic rewriter dispatch.
All 311 tests passing at time of audit.

---

## Bugs (Correctness)

### 1. ~~`TotalRulesEvaluated` is always 0~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `Evaluate()` method
**Issue:** `totalRules` was initialized to 0 and never incremented.
**Fix:** Added `RulesEvaluated` property to `EvaluationResultImpl<T>`, set from `rules.Count` in `EvaluateFactSet<T>`, read back via reflection in `Evaluate()` — same pattern as existing `Matches` and `Count` reads.
**Test:** `SessionTests.Session_Evaluate_ReportsTotalRulesEvaluated` — verifies 2 rules yield `TotalRulesEvaluated == 2`.

### 2. ~~Stale cache on re-evaluation~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `_rewrittenConditionCache` (Path 3), `Rule.cs` — `_sessionCompiledCache` (Path 2)
**Issue:** Both caches baked session fact data into compiled delegates via `Expression.Constant(facts)`. If a session inserted more facts after the first `Evaluate()` call and evaluated again, cached delegates still referenced the old fact snapshot.
**Fix:** Clear both caches at the start of each `EvaluateFactSet<T>()`: `_rewrittenConditionCache.Clear()` for Path 3 and `Rule<T>.ClearSessionCache(SessionId)` for Path 2. Rewriter creates fresh delegates on each evaluation.
**Tests:** `Session_ReEvaluation_ReflectsNewlyInsertedFactType` (Path 2), `Session_ReEvaluation_Path3_ReflectsNewFacts` (Path 3).

### 3. ~~`Rule<T>.ClearSessionCache` is never called~~ **FIXED 2026-02-06**
**File:** `Rule.cs` — `ClearSessionCache(Guid sessionId)`, `Implementation.cs` — `RuleSession.Dispose()`
**Issue:** `RuleSession.Dispose()` didn't call `ClearSessionCache` on any rules. Each session left behind compiled delegates inside every cross-fact rule it touched.
**Fix:** `RuleSession.Dispose()` now calls `ClearAllRuleSessionCaches()`, which iterates all fact types and calls `ClearSessionCache(SessionId)` on each `Rule<T>`. Also clears `_rewrittenConditionCache`.

### 4. Detector/Rewriter asymmetry
**File:** `Provider.cs` — `FactQueryDetector` vs `FactQueryRewriter`
**Issue:** `FactQueryDetector.VisitConstant` detects `FactQueryable<T>` in constant nodes. `FactQueryRewriter` does NOT override `VisitConstant`, so it can't rewrite those same nodes. Both classes DO handle `VisitMember` (closure member access) and `VisitExtension` (direct `FactQueryExpression`).
**Risk (revised 2026-02-06):** Lower than originally assessed. C# closure capture always wraps variables in `MemberAccess(Constant(DisplayClass), fieldName)` — never as a bare `ConstantExpression`. Both detector and rewriter handle `VisitMember`. The gap only affects hand-built expression trees using `Expression.Constant(factQueryable)` directly. Failure mode is NOT silent — `FactQueryable.GetEnumerator()` throws `InvalidOperationException`, caught by the error handler in `EvaluateFactSet` (line 599). Rule is skipped and appears in `Errors`. **Downgraded from P0 to P2.**
**Fix:** `FactQueryRewriter` should add `VisitConstant` to match `FactQueryDetector` for completeness.

### 5. ~~`ContainsFactQuery()` called per-fact, not per-rule~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `EvaluateFactSet<T>()`, Path 3 dispatch
**Issue:** The check `FactQueryExpression.ContainsFactQuery(rule.Condition)` was inside the fact loop, walking the entire expression tree once per fact per rule.
**Fix:** Restructured `EvaluateFactSet<T>()` to pre-classify rules into a `List<(IRule<T>, RuleDispatchKind)>` before the fact loop. Classification (including `ContainsFactQuery`) runs once per rule. Inner loop uses `switch (kind)` dispatch. Added private `RuleDispatchKind` enum (Dependent, ClosureRewriting, GenericRewriting, Standard).

### 6. ~~`Evaluate<T>()` single-type overload skips state transition~~ **FIXED 2026-02-06**
**File:** `Implementation.cs` — `Evaluate<T>()` vs `Evaluate()`
**Issue:** The single-type `Evaluate<T>()` overload skipped setting `_state = SessionState.Evaluating`, meaning rule actions could call `session.Insert()` during evaluation.
**Fix:** `Evaluate<T>()` now sets `_state = SessionState.Evaluating` in a try/finally block, matching `Evaluate()`.
**Test:** `SessionTests.Session_EvaluateT_SetsStateToEvaluating` — captures session state during a rule action and verifies it was `Evaluating`.

---

## Design Flaws (Consistency)

### 7. `DependentRule.Execute` vs `Rule<T>.Execute` inconsistency
**File:** `DependencyAnalysis.cs` — `DependentRule<T>.Execute()`, `Rule.cs` — `Rule<T>.Execute()`
**Issue:** `Rule<T>.Execute()` checks the condition first and returns `RuleResult.NoMatch` if false. `DependentRule<T>.Execute()` runs the action unconditionally and returns `RuleResult.Success`. A caller using `Execute()` without prior `Evaluate()` gets different behavior depending on the rule type.
**Impact:** Low — `EvaluateFactSet` always checks the condition first. But the asymmetry is a trap for direct callers.

### 8. `FindByKey` ignores schema's `HasKey` configuration
**File:** `Implementation.cs` — `FactSet<T>.FindByKey()`, `DependencyAnalysis.cs` — `FactTypeSchemaBuilder.HasKey()`
**Issue:** `FindByKey` always looks for a property named `"Id"` via reflection and uses string comparison. The `FactTypeSchemaBuilder.HasKey()` configuration exists but is completely ignored by `FindByKey`.
**Impact:** Medium — misleading API. Users configure `HasKey(x => x.Code)` but `FindByKey("ABC")` still searches for property `Id`.

### 9. `RegisteredFactTypes` returns wrong set
**File:** `Implementation.cs` — `RuleSession.RegisteredFactTypes`
**Issue:** `IFactContext.RegisteredFactTypes` is semantically "all registered fact types in the schema" but the implementation returns only types that have been inserted into the session via `InsertAll<T>()`.
**Impact:** Medium — `DependentRule` actions that check `RegisteredFactTypes` to decide whether to query a fact type will get inconsistent answers depending on insertion order.

### 10. `GetFacts()` returns the live backing list
**File:** `Implementation.cs` — `FactSet<T>.GetFacts()`
**Issue:** Returns the internal `List<T>` directly (cast as `IReadOnlyList<T>`). Callers can downcast to `List<T>` and mutate it. The rewriter's `Expression.Constant(facts)` captures this same reference, so external mutations propagate into compiled rule conditions unpredictably.
**Fix:** Return `_facts.AsReadOnly()` or a snapshot copy.

---

## Test Coverage Gaps

### 11. ~~Zero tests for DependencyGraph cycle detection~~ **FIXED 2026-02-06**
**File:** `DependencyAnalysis.cs` — `TopologicalVisit()`, `WouldCreateCycle()`
**Fix:** Added 6 tests to `FactContextIntegrationTests`: direct cycle, transitive cycle, self-referential cycle (all throw `InvalidOperationException` on `GetLoadOrder()`); `WouldCreateCycle` detects direct and transitive cycles; valid dependency returns false.

### 12. Zero tests for error accumulation in EvaluateFactSet
**File:** `Implementation.cs` — `EvaluateFactSet` try-catch, `_errors` list
**Missing:** No test ever verifies that `IEvaluationResult.HasErrors` returns true or that exceptions from rule evaluation are captured in the errors list. Exceptions are silently swallowed.

### 13. Zero tests for ContextConditionProjector error paths
**File:** `DependencyAnalysis.cs` — `ContextConditionProjector.VisitMethodCall()`
**Missing:** `FindByKey<T>()` should throw `NotSupportedException`. Unsupported `IFactContext` methods should throw. Neither is tested.

### 14. False-positive test: `ClosureCapture_SessionCacheIsUsed_ForSameSession`
**File:** `FactContextIntegrationTests.cs`
**Issue:** Test name claims to verify cache usage but only verifies two messages match the same rule. Passes identically with or without caching. No observable behavior proves the cache was consulted.

### 15. ~~Zero tests for multiple `Evaluate()` calls on same session~~ **FIXED 2026-02-06**
**Fix:** The #2 fix tests (`Session_ReEvaluation_ReflectsNewlyInsertedFactType`, `Session_ReEvaluation_Path3_ReflectsNewFacts`) exercise multiple evaluations on the same session. Sessions support re-evaluation with correct cache invalidation.

### 16. Zero tests for session lifecycle edge cases
**Missing:** Using a disposed session, inserting after rollback, double-dispose.

---

## Dead Code

### 17. `FactWithRulesQueryable<T>` (Rule.cs)
Never instantiated anywhere. Would break on rewriting-required rules (no `GetOrCompileWithRewriter` implementation).

### 18. `DependencyExtractor._currentFactType` (DependencyAnalysis.cs)
Field is assigned but never read.

---

## Priority Order for Fixes

| Priority | Item | Risk |
|----------|------|------|
| ~~**P0**~~ | ~~#2 Stale cache on re-evaluation~~ | ~~Silent wrong results~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#5 ContainsFactQuery per-fact perf~~ | ~~O(facts × rules × tree-depth) waste~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#3 ClearSessionCache never called~~ | ~~Unbounded memory growth~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#1 TotalRulesEvaluated always 0~~ | ~~Broken metrics~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#6 Evaluate<T> skips state transition~~ | ~~Mutation during evaluation~~ **FIXED 2026-02-06** |
| ~~**P1**~~ | ~~#11 Cycle detection untested~~ | ~~Could corrupt graph silently~~ **FIXED 2026-02-06** |
| **P2** | #4 Detector/Rewriter asymmetry (downgraded) | Hand-built expr trees only; throws, not silent |
| **P2** | #12 Error accumulation untested | Silent exception swallowing |
| **P2** | #13 Projector error paths untested | Undocumented failure modes |
| **P2** | #10 GetFacts returns live list | Unpredictable mutations |
| **P2** | #8 FindByKey ignores HasKey | Misleading API |
| **P2** | #9 RegisteredFactTypes wrong set | Inconsistent query behavior |
| **P3** | #7 Execute inconsistency | Trap for direct callers |
| **P3** | #14-16 Test quality issues | False confidence |
| **P3** | #17-18 Dead code | Cleanup |
